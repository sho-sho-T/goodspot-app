# リポジトリ読取りプレイブック（Repo Reading Playbook）

## 目的
ユーザーの指示から、関連コードを最短で特定し、根拠に基づいた実装計画を作るための手順。

---

## 0. 入力の正規化（最初にやる）
- ユーザー指示を以下に分解する
  - **何を**（機能/挙動）
  - **誰が**（利用者・権限・主体）
  - **いつ**（タイミング・トリガ）
  - **どこで**（画面/API/バッチ/ジョブ）
  - **なぜ**（背景・意図）
- **受け入れ条件**を3〜7個に落とす（箇条書き）
- 不確定があっても、まずは探索で埋められるか確認してから質問する

---

## 1. 探索方針（progressive disclosure）
### 優先順位
1. 既存の類似機能（同じユースケース/同じ画面/同じAPI）
2. 入口（エンドポイント/ルーティング/コントローラ/ハンドラ/ページ）
3. 中核ロジック（サービス/ユースケース/ドメイン/モデル）
4. 永続化（DB/ORM/リポジトリ/クエリ）
5. 周辺（設定、バリデーション、認可、監査ログ、ジョブ）
6. テスト（既存spec、fixtures、factories、E2E）

### まず「広く浅く」
- 最初は `rg` で **候補を列挙**し、上位数ファイルだけを読む
- いきなり深掘りしない（全読み/広範囲の依存追跡は最後）

---

## 2. 探索クエリ（rg / git grep）の作り方
### ベース
- ユーザーの名詞（機能名、画面名、API名、文言、エラー文）
- ドメイン用語（例: loan, borrower, inventory など）
- 重要な動詞（create/update/delete/approve/export 等）

### よく使うパターン
- UI:
  - `rg -n "画面名|label|文言|testid|route" .`
- API:
  - `rg -n "endpoint|controller|router|GET|POST|/path" .`
- DB/Model:
  - `rg -n "class .*|schema|migration|table|column" .`
- 権限/認可:
  - `rg -n "authorize|policy|permission|role" .`
- バリデーション:
  - `rg -n "validate|validation|errors\.add|before_" .`
- ジョブ/バッチ:
  - `rg -n "job|worker|cron|schedule" .`

### git の使い方（軽く）
- 最近触られたファイルを参考にする:
  - `git log -n 20 --oneline -- <path>`
- 類似実装のコミットを探す（キーワード）:
  - `git log --oneline --grep "<keyword>" -n 30`

---

## 3. 読むときのコツ（必要箇所だけ）
- 入口ファイルは「関数/メソッドの責務」「呼び出し先」を確認
- 依存を辿るときは、次のどれかに該当するものだけ読む
  - 仕様が決まる場所（条件分岐、バリデーション、計算ロジック）
  - 変更が必要そうな場所（データ生成、更新、永続化、認可）
  - テストや利用箇所（呼び出し元、UI、API、ジョブ）

---

## 4. 根拠（Evidence）の残し方
実装計画では、以下の形式で根拠を残す：
- `path/to/file:line-or-symbol`（行番号が取れないならシンボル名でもよい）
- 「既存と同じパターン」を言う場合は、必ず類似実装の場所を挙げる

---

## 5. 変更設計の方針（計画品質を上げる）
- 既存の責務境界（レイヤ分割、命名、例外方針）を守る
- 「追加」より「既存パターンの再利用」を優先
- 仕様が確定していない部分は、計画の最後に **未確定事項/質問** として分離する
- 破壊的変更・DB変更は影響範囲とロールバック方針を必ず書く

---

## 6. 出力チェック（最低限）
- 変更ファイル一覧が具体か
- 手順が実装者がそのまま作業できる粒度か
- リスクとテストが漏れていないか
- 未確定事項が質問として切り出されているか